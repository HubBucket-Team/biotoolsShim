<?xml version="1.0" encoding="UTF-8"?>
<!--
This file was generated by Altova MapForce 2015sp2

YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.

Refer to the Altova MapForce Documentation for further details.
http://www.altova.com/mapforce
-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" exclude-result-prefixes="xs fn">
	<xsl:output method="xml" encoding="UTF-8" byte-order-mark="no" indent="yes"/>
	<xsl:template match="/">
		<tools xmlns="http://bio.tools">
			<xsl:attribute name="xsi:schemaLocation" namespace="http://www.w3.org/2001/XMLSchema-instance" select="'http://bio.tools D:/repos/GitHub/biotoolsShim/genericxml2xml/versions/biotools-3.0.0/biotools_3.0.0.xsd'"/>
			<xsl:for-each select="*:tools[fn:namespace-uri() eq '']/*:root[fn:namespace-uri() eq '']">
				<tool>
					<summary>
						<name>
							<xsl:sequence select="fn:string(*:name[fn:namespace-uri() eq ''])"/>
						</name>
						<shortDescription>
							<xsl:sequence select="fn:string(*:shortDescription[fn:namespace-uri() eq ''])"/>
						</shortDescription>
						<description>
							<xsl:sequence select="fn:string(*:description[fn:namespace-uri() eq ''])"/>
						</description>
						<homepage>
							<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:homepage[fn:namespace-uri() eq ''])))"/>
						</homepage>
						<biotoolsID>
							<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:biotoolsID[fn:namespace-uri() eq ''])))"/>
						</biotoolsID>
						<biotoolsCURIE>
							<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:biotoolsCURIE[fn:namespace-uri() eq ''])))"/>
						</biotoolsCURIE>
						<xsl:for-each select="*:version[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<version>
								<xsl:sequence select="fn:string(.)"/>
							</version>
						</xsl:for-each>
						<xsl:for-each select="*:otherID[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<otherID>
								<value>
									<xsl:sequence select="fn:string(*:value[fn:namespace-uri() eq ''])"/>
								</value>
								<type>
									<xsl:sequence select="fn:string(*:type[fn:namespace-uri() eq ''])"/>
								</type>
								<version>
									<xsl:sequence select="fn:string(*:version[fn:namespace-uri() eq ''])"/>
								</version>
							</otherID>
						</xsl:for-each>
					</summary>
					<xsl:for-each select="*:function[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
						<function>
							<xsl:for-each select="*:operation[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
								<operation>
									<uri>
										<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:uri[fn:namespace-uri() eq ''])))"/>
									</uri>
									<term>
										<xsl:sequence select="fn:string(*:term[fn:namespace-uri() eq ''])"/>
									</term>
								</operation>
							</xsl:for-each>
							<xsl:for-each select="*:input[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
								<input>
									<data>
										<uri>
											<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:data[fn:namespace-uri() eq '']/*:uri[fn:namespace-uri() eq ''])))"/>
										</uri>
										<term>
											<xsl:sequence select="fn:string(*:data[fn:namespace-uri() eq '']/*:term[fn:namespace-uri() eq ''])"/>
										</term>
									</data>
									<xsl:for-each select="*:format[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
										<format>
											<uri>
												<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:uri[fn:namespace-uri() eq ''])))"/>
											</uri>
											<term>
												<xsl:sequence select="fn:string(*:term[fn:namespace-uri() eq ''])"/>
											</term>
										</format>
									</xsl:for-each>
								</input>
							</xsl:for-each>
							<xsl:for-each select="*:output[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
								<output>
									<data>
										<uri>
											<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:data[fn:namespace-uri() eq '']/*:uri[fn:namespace-uri() eq ''])))"/>
										</uri>
										<term>
											<xsl:sequence select="fn:string(*:data[fn:namespace-uri() eq '']/*:term[fn:namespace-uri() eq ''])"/>
										</term>
									</data>
									<xsl:for-each select="*:format[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
										<format>
											<uri>
												<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:uri[fn:namespace-uri() eq ''])))"/>
											</uri>
											<term>
												<xsl:sequence select="fn:string(*:term[fn:namespace-uri() eq ''])"/>
											</term>
										</format>
									</xsl:for-each>
								</output>
							</xsl:for-each>
							<comment>
								<xsl:sequence select="fn:string(*:comment[fn:namespace-uri() eq ''])"/>
							</comment>
							<cmd>
								<xsl:sequence select="fn:string(*:cmd[fn:namespace-uri() eq ''])"/>
							</cmd>
						</function>
					</xsl:for-each>
					<labels>
						<xsl:for-each select="*:toolType[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<toolType>
								<xsl:sequence select="fn:string(.)"/>
							</toolType>
						</xsl:for-each>
						<xsl:for-each select="*:topic[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<topic>
								<uri>
									<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:uri[fn:namespace-uri() eq ''])))"/>
								</uri>
								<term>
									<xsl:sequence select="fn:string(*:term[fn:namespace-uri() eq ''])"/>
								</term>
							</topic>
						</xsl:for-each>
						<xsl:for-each select="*:goTermID[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<goTermID>
								<xsl:sequence select="fn:string(.)"/>
							</goTermID>
						</xsl:for-each>
						<xsl:for-each select="*:soTermID[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<soTermID>
								<xsl:sequence select="fn:string(.)"/>
							</soTermID>
						</xsl:for-each>
						<xsl:for-each select="*:taxID[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<taxID>
								<xsl:sequence select="fn:string(.)"/>
							</taxID>
						</xsl:for-each>
						<xsl:for-each select="*:operatingSystem[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<operatingSystem>
								<xsl:sequence select="fn:string(.)"/>
							</operatingSystem>
						</xsl:for-each>
						<xsl:for-each select="*:language[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<language>
								<xsl:sequence select="fn:string(.)"/>
							</language>
						</xsl:for-each>
						<license>
							<xsl:sequence select="fn:string(*:license[fn:namespace-uri() eq ''])"/>
						</license>
						<xsl:for-each select="*:collectionID[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<collectionID>
								<xsl:sequence select="fn:string(.)"/>
							</collectionID>
						</xsl:for-each>
						<maturity>
							<xsl:sequence select="fn:string(*:maturity[fn:namespace-uri() eq ''])"/>
						</maturity>
						<cost>
							<xsl:sequence select="fn:string(*:cost[fn:namespace-uri() eq ''])"/>
						</cost>
						<xsl:for-each select="*:accessibility[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<accessibility>
								<xsl:sequence select="fn:string(.)"/>
							</accessibility>
						</xsl:for-each>
					</labels>
					<xsl:for-each select="*:relation[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
						<relation>
							<biotoolsID>
								<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:biotoolsId[fn:namespace-uri() eq ''])))"/>
							</biotoolsID>
							<type>
								<xsl:sequence select="fn:string(*:type[fn:namespace-uri() eq ''])"/>
							</type>
						</relation>
					</xsl:for-each>
					<apiSpec>
						<baseURL>
							<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:apiSpec[fn:namespace-uri() eq '']/*:baseURL[fn:namespace-uri() eq ''])))"/>
						</baseURL>
						<xsl:for-each select="*:apiSpec[fn:namespace-uri() eq '']/*:endpoint[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
							<endpoint>
								<httpMethod>
									<xsl:sequence select="fn:string(*:httpMethod[fn:namespace-uri() eq ''])"/>
								</httpMethod>
								<urlTemplate>
									<xsl:sequence select="fn:string(*:urlTemplate[fn:namespace-uri() eq ''])"/>
								</urlTemplate>
								<output>
									<data>
										<uri>
											<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:output[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']/*:data[fn:namespace-uri() eq '']/*:uri[fn:namespace-uri() eq ''])))"/>
										</uri>
										<term>
											<xsl:sequence select="fn:string(*:output[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']/*:data[fn:namespace-uri() eq '']/*:term[fn:namespace-uri() eq ''])"/>
										</term>
									</data>
									<xsl:for-each select="*:output[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']/*:format[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
										<format>
											<uri>
												<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:uri[fn:namespace-uri() eq ''])))"/>
											</uri>
											<term>
												<xsl:sequence select="fn:string(*:term[fn:namespace-uri() eq ''])"/>
											</term>
										</format>
									</xsl:for-each>
								</output>
								<summary>
									<xsl:sequence select="fn:string(*:summary[fn:namespace-uri() eq ''])"/>
								</summary>
								<xsl:for-each select="*:parameter[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
									<parameter>
										<urlTemplateFragment>
											<xsl:sequence select="fn:string(*:urlTemplateFragment[fn:namespace-uri() eq ''])"/>
										</urlTemplateFragment>
										<data>
											<uri>
												<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:data[fn:namespace-uri() eq '']/*:uri[fn:namespace-uri() eq ''])))"/>
											</uri>
											<term>
												<xsl:sequence select="fn:string(*:data[fn:namespace-uri() eq '']/*:term[fn:namespace-uri() eq ''])"/>
											</term>
										</data>
										<comment>
											<xsl:sequence select="fn:string(*:comment[fn:namespace-uri() eq ''])"/>
										</comment>
									</parameter>
								</xsl:for-each>
							</endpoint>
						</xsl:for-each>
					</apiSpec>
					<xsl:for-each select="*:link[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
						<link>
							<url>
								<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:url[fn:namespace-uri() eq ''])))"/>
							</url>
							<isAvailable>
								<xsl:sequence select="fn:string(*:isAvailable[fn:namespace-uri() eq ''])"/>
							</isAvailable>
							<type>
								<xsl:sequence select="fn:string(*:type[fn:namespace-uri() eq ''])"/>
							</type>
							<comment>
								<xsl:sequence select="fn:string(*:comment[fn:namespace-uri() eq ''])"/>
							</comment>
						</link>
					</xsl:for-each>
					<xsl:for-each select="*:download[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
						<download>
							<url>
								<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:url[fn:namespace-uri() eq ''])))"/>
							</url>
							<isAvailable>
								<xsl:sequence select="fn:string(*:isAvailable[fn:namespace-uri() eq ''])"/>
							</isAvailable>
							<type>
								<xsl:sequence select="fn:string(*:type[fn:namespace-uri() eq ''])"/>
							</type>
							<comment>
								<xsl:sequence select="fn:string(*:comment[fn:namespace-uri() eq ''])"/>
							</comment>
							<diskFormat>
								<xsl:sequence select="fn:string(*:diskFormat[fn:namespace-uri() eq ''])"/>
							</diskFormat>
							<containerFormat>
								<xsl:sequence select="fn:string(*:containerFormat[fn:namespace-uri() eq ''])"/>
							</containerFormat>
							<cmd>
								<xsl:sequence select="fn:string(*:cmd[fn:namespace-uri() eq ''])"/>
							</cmd>
							<version>
								<xsl:sequence select="fn:string(*:version[fn:namespace-uri() eq ''])"/>
							</version>
						</download>
					</xsl:for-each>
					<xsl:for-each select="*:documentation[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
						<documentation>
							<url>
								<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:url[fn:namespace-uri() eq ''])))"/>
							</url>
							<isAvailable>
								<xsl:sequence select="fn:string(*:isAvailable[fn:namespace-uri() eq ''])"/>
							</isAvailable>
							<type>
								<xsl:sequence select="fn:string(*:type[fn:namespace-uri() eq ''])"/>
							</type>
							<comment>
								<xsl:sequence select="fn:string(*:comment[fn:namespace-uri() eq ''])"/>
							</comment>
						</documentation>
					</xsl:for-each>
					<xsl:for-each select="*:publication[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
						<publication>
							<isAvailable>
								<xsl:sequence select="fn:string(*:isAvailable[fn:namespace-uri() eq ''])"/>
							</isAvailable>
							<doi>
								<xsl:sequence select="fn:string(*:doi[fn:namespace-uri() eq ''])"/>
							</doi>
							<pmid>
								<xsl:sequence select="fn:string(*:pmid[fn:namespace-uri() eq ''])"/>
							</pmid>
							<pmcid>
								<xsl:sequence select="fn:string(*:pmcid[fn:namespace-uri() eq ''])"/>
							</pmcid>
							<type>
								<xsl:sequence select="fn:string(*:type[fn:namespace-uri() eq ''])"/>
							</type>
							<version>
								<xsl:sequence select="fn:string(*:version[fn:namespace-uri() eq ''])"/>
							</version>
						</publication>
					</xsl:for-each>
					<xsl:for-each select="*:credit[fn:namespace-uri() eq '']/*:list-item[fn:namespace-uri() eq '']">
						<credit>
							<elixirPlatform>
								<xsl:sequence select="fn:string(*:elixirPlatform[fn:namespace-uri() eq ''])"/>
							</elixirPlatform>
							<elixirNode>
								<xsl:sequence select="fn:string(*:elixirNode[fn:namespace-uri() eq ''])"/>
							</elixirNode>
							<name>
								<xsl:sequence select="fn:string(*:name[fn:namespace-uri() eq ''])"/>
							</name>
							<orcidid>
								<xsl:sequence select="fn:string(*:orcidId[fn:namespace-uri() eq ''])"/>
							</orcidid>
							<gridid>
								<xsl:sequence select="fn:string(*:gridId[fn:namespace-uri() eq ''])"/>
							</gridid>
							<email>
								<xsl:sequence select="fn:string(*:email[fn:namespace-uri() eq ''])"/>
							</email>
							<url>
								<xsl:sequence select="xs:string(xs:anyURI(fn:string(*:url[fn:namespace-uri() eq ''])))"/>
							</url>
							<tel>
								<xsl:sequence select="fn:string(*:tel[fn:namespace-uri() eq ''])"/>
							</tel>
							<typeEntity>
								<xsl:sequence select="fn:string(*:typeEntity[fn:namespace-uri() eq ''])"/>
							</typeEntity>
							<typeRole>
								<xsl:sequence select="fn:string(*:typeRole[fn:namespace-uri() eq ''])"/>
							</typeRole>
							<comment>
								<xsl:sequence select="fn:string(*:comment[fn:namespace-uri() eq ''])"/>
							</comment>
						</credit>
					</xsl:for-each>
					<elixirInfo>
						<lastReviewExternalSab>
							<xsl:sequence select="xs:string(xs:date(fn:string(*:elixirInfo[fn:namespace-uri() eq '']/*:lastReviewExternalSab[fn:namespace-uri() eq ''])))"/>
						</lastReviewExternalSab>
						<lastReviewElixirSab>
							<xsl:sequence select="xs:string(xs:date(fn:string(*:elixirInfo[fn:namespace-uri() eq '']/*:lastReviewElixirSab[fn:namespace-uri() eq ''])))"/>
						</lastReviewElixirSab>
						<inSDP>
							<xsl:sequence select="xs:string(xs:boolean(fn:string(*:elixirInfo[fn:namespace-uri() eq '']/*:inSDP[fn:namespace-uri() eq ''])))"/>
						</inSDP>
						<isCoreDataResource>
							<xsl:sequence select="xs:string(xs:boolean(fn:string(*:elixirInfo[fn:namespace-uri() eq '']/*:isCoreDataResource[fn:namespace-uri() eq ''])))"/>
						</isCoreDataResource>
						<comment>
							<xsl:sequence select="fn:string(*:elixirInfo[fn:namespace-uri() eq '']/*:comment[fn:namespace-uri() eq ''])"/>
						</comment>
					</elixirInfo>
				</tool>
			</xsl:for-each>
		</tools>
	</xsl:template>
</xsl:stylesheet>
